import random
import time
from datetime import datetime, timedelta
import os
import re

# Generated by LLM!
def create_log_file(filename="app.log", target_size_mb=100):
    """
    Creates a realistic 100MB log file with various log levels and messages
    """
    # Log levels with weights (INFO appears most often)
    log_levels = ["INFO", "WARNING", "ERROR", "DEBUG", "CRITICAL", "THREAT"]
    level_weights = [400, 250, 50, 250, 1, 49]

    # Realistic log components
    components = [
        "Authentication", "Database", "Network", "Security", "API",
        "Cache", "FileSystem", "Session", "Payment", "Notification",
        "Worker", "Queue", "WebServer", "Monitoring", "Backup"
    ]

    # Common log messages templates - SIMPLIFIED to avoid parsing issues
    templates = {
        "INFO": [
            "{component}: User {user} logged in from {ip}",
            "{component}: Request processed in {time}ms",
            "{component}: {action} completed successfully",
            "{component}: Connection established to {service}",
            "{component}: Cache updated for {key}"
        ],
        "WARNING": [
            "{component}: High latency detected ({time}ms)",
            "{component}: {resource} usage at {percent}%",
            "{component}: Retry attempt {attempt} for {operation}",
            "{component}: Deprecated API called by {caller}",
            "{component}: Unusual activity detected from {source}"
        ],
        "ERROR": [
            "{component}: Failed to connect to {service}: {reason}",
            "{component}: {operation} failed with exception: {exception}",
            "{component}: Database constraint violation: {details}",
            "{component}: Timeout after {timeout}s for {task}",
            "{component}: {file} not found or inaccessible"
        ],
        "THREAT": [
            "{component}: Multiple failed login attempts from {ip}",
            "{component}: Suspicious SQL injection pattern detected",
            "{component}: Unauthorized access attempt to {resource}",
            "{component}: Malware signature detected in {file}",
            "{component}: Brute force attack detected from {ip_range}"
        ],
        "DEBUG": [
            "{component}: Processing item {id} with data: {data}",
            "{component}: Entering function {function} with args {args}",
            "{component}: Variable {var} = {value}",
            "{component}: Step {step}/{total} completed",
            "{component}: Memory usage: {memory} MB"
        ],
        "CRITICAL": [
            "{component}: SYSTEM FAILURE: {service} is down",
            "{component}: Database corruption detected",
            "{component}: Disk space critically low ({free} MB left)",
            "{component}: Security breach detected: {details}",
            "{component}: Application cannot start: {reason}"
        ]
    }

    # Additional realistic data
    users = [f"user_{i}" for i in range(1, 101)]
    ips = [f"192.168.{random.randint(1, 255)}.{random.randint(1, 255)}" for _ in range(50)]
    services = ["MySQL", "Redis", "Elasticsearch", "MongoDB", "RabbitMQ", "Kafka", "PostgreSQL"]
    exceptions = ["TimeoutException", "IOException", "SQLException", "NetworkException",
                  "AuthenticationException", "AuthorizationException", "ValidationException"]

    # Helper function to extract placeholders from template
    def get_placeholders(template):
        """Extract all {placeholder} names from template string"""
        return re.findall(r'\{(\w+)\}', template)

    target_bytes = target_size_mb * 1024 * 1024
    bytes_written = 0
    log_count = 0
    start_time = datetime.now() - timedelta(days=30)  # Start 30 days ago

    print(f"Creating {target_size_mb}MB log file: {filename}")
    start_real = time.time()

    with open(filename, "w", encoding="utf-8") as f:
        while bytes_written < target_bytes:
            # Generate timestamp (increment by random intervals)
            time_increment = random.randint(1, 300)  # 1-300 seconds between logs
            start_time += timedelta(seconds=time_increment)
            timestamp = start_time.strftime("%Y-%m-%d %H:%M:%S,%f")[:-3]

            # Choose log level
            level = random.choices(log_levels, weights=level_weights, k=1)[0]

            # Choose component
            component = random.choice(components)

            # Generate log message
            template = random.choice(templates[level])

            # Get placeholders from template
            placeholders = get_placeholders(template)

            # Create message data dictionary
            message_data = {}
            for placeholder in placeholders:
                if placeholder == "component":
                    message_data[placeholder] = component
                elif placeholder == "user":
                    message_data[placeholder] = random.choice(users)
                elif placeholder == "ip":
                    message_data[placeholder] = random.choice(ips)
                elif placeholder == "time":
                    message_data[placeholder] = random.randint(10, 5000)
                elif placeholder == "action":
                    message_data[placeholder] = random.choice(["Backup", "Sync", "Export", "Import", "Update"])
                elif placeholder == "service":
                    message_data[placeholder] = random.choice(services)
                elif placeholder == "key":
                    message_data[placeholder] = f"key_{random.randint(1, 10000)}"
                elif placeholder == "resource":
                    message_data[placeholder] = random.choice(["CPU", "Memory", "Disk", "Network"])
                elif placeholder == "percent":
                    message_data[placeholder] = random.randint(70, 99)
                elif placeholder == "attempt":
                    message_data[placeholder] = random.randint(1, 5)
                elif placeholder == "operation":
                    message_data[placeholder] = random.choice(["Query", "Transaction", "Upload", "Download"])
                elif placeholder == "caller":
                    message_data[placeholder] = random.choice(users)
                elif placeholder == "source":
                    message_data[placeholder] = random.choice(ips)
                elif placeholder == "reason":
                    message_data[placeholder] = random.choice(
                        ["connection refused", "timeout", "authentication failed"])
                elif placeholder == "exception":
                    message_data[placeholder] = random.choice(exceptions)
                elif placeholder == "details":
                    message_data[placeholder] = f"Error code: {random.randint(1000, 9999)}"
                elif placeholder == "timeout":
                    message_data[placeholder] = random.randint(30, 300)
                elif placeholder == "task":
                    message_data[placeholder] = random.choice(["data processing", "file upload", "API call"])
                elif placeholder == "file":
                    message_data[placeholder] = f"/var/log/{random.choice(['app', 'system', 'auth'])}.log"
                elif placeholder == "ip_range":
                    message_data[placeholder] = f"{random.randint(10, 200)}.{random.randint(0, 255)}.0.0/24"
                elif placeholder == "id":
                    message_data[placeholder] = random.randint(1000, 99999)
                elif placeholder == "data":
                    message_data[
                        placeholder] = f"{{'id': {random.randint(1, 100)}, 'status': '{random.choice(['active', 'pending', 'completed'])}'}}"
                elif placeholder == "function":
                    message_data[placeholder] = random.choice(["process_request", "validate_data", "generate_report"])
                elif placeholder == "args":
                    message_data[placeholder] = f"{random.randint(1, 10)} arguments"
                elif placeholder == "var":
                    message_data[placeholder] = random.choice(["counter", "result", "config", "payload"])
                elif placeholder == "value":
                    message_data[placeholder] = random.choice(["null", "true", "false", str(random.randint(0, 100))])
                elif placeholder == "step":
                    message_data[placeholder] = random.randint(1, 10)
                elif placeholder == "total":
                    message_data[placeholder] = 10
                elif placeholder == "memory":
                    message_data[placeholder] = random.randint(100, 5000)
                elif placeholder == "free":
                    message_data[placeholder] = random.randint(1, 100)
                else:
                    message_data[placeholder] = "N/A"

            # Format the message
            try:
                message = template.format(**message_data)
            except KeyError as e:
                # Fallback in case of any formatting error
                message = f"{component}: Log message {random.randint(1, 10000)}"

            # Create log line
            log_line = f"{timestamp} [{level}] {message}\n"

            # Write to file
            f.write(log_line)
            bytes_written += len(log_line.encode('utf-8'))
            log_count += 1

            # Progress indicator
            if log_count % 10000 == 0:
                progress = (bytes_written / target_bytes) * 100
                print(f"Progress: {progress:.1f}% ({bytes_written / (1024 * 1024):.1f} MB, {log_count} logs)", end='\r')

    end_real = time.time()
    actual_size_mb = bytes_written / (1024 * 1024)

    print(f"\n{'=' * 50}")
    print(f"Log file created: {filename}")
    print(f"Target size: {target_size_mb} MB")
    print(f"Actual size: {actual_size_mb:.2f} MB")
    print(f"Number of log entries: {log_count:,}")
    print(f"Time taken: {end_real - start_real:.2f} seconds")
    print(f"Average log line size: {bytes_written / log_count:.0f} bytes")

    return filename


# Alternative: Even Simpler Version (No Template Parsing Issues)
def create_simple_log_file(filename="simple.log", target_size_mb=100):
    """Simpler version that avoids template parsing complexity"""

    log_levels = ["INFO", "WARNING", "ERROR", "DEBUG", "CRITICAL", "THREAT"]
    level_weights = [400, 250, 50, 250, 1, 49]

    components = ["Auth", "DB", "Network", "Security", "API", "Cache", "FileSystem"]

    # Pre-generated message parts
    actions = ["login", "query", "update", "delete", "scan", "backup", "restore", "sync"]
    users = [f"user_{i}" for i in range(1, 1001)]
    ips = [f"10.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(1, 254)}" for _ in range(100)]
    error_codes = [f"ERR_{random.randint(1000, 9999)}" for _ in range(50)]

    target_bytes = target_size_mb * 1024 * 1024
    bytes_written = 0
    log_count = 0
    current_time = datetime.now() - timedelta(days=30)

    print(f"Creating {target_size_mb}MB log file: {filename}")

    with open(filename, "w", encoding="utf-8") as f:
        while bytes_written < target_bytes:
            # Update timestamp
            current_time += timedelta(seconds=random.randint(1, 300))
            timestamp = current_time.strftime("%Y-%m-%d %H:%M:%S")

            # Choose log level
            level = random.choices(log_levels, weights=level_weights, k=1)[0]
            component = random.choice(components)

            # Generate message based on level
            if level == "INFO":
                msg = f"{component}: User {random.choice(users)} {random.choice(actions)} from {random.choice(ips)}"
            elif level == "WARNING":
                msg = f"{component}: {random.choice(['High latency', 'High memory usage', 'Retry attempt'])} detected"
            elif level == "ERROR":
                msg = f"{component}: Failed to {random.choice(actions)}: {random.choice(error_codes)}"
            elif level == "THREAT":
                msg = f"{component}: {random.choice(['Suspicious activity', 'Brute force attempt'])} from {random.choice(ips)}"
            elif level == "DEBUG":
                msg = f"{component}: Debug info: {random.randint(1, 1000)} items processed"
            else:  # CRITICAL
                msg = f"{component}: CRITICAL: {random.choice(['System failure', 'Database down', 'Security breach'])}"

            log_line = f"{timestamp} [{level}] {msg}\n"
            bytes_written += len(log_line.encode('utf-8'))
            f.write(log_line)
            log_count += 1

            if log_count % 50000 == 0:
                progress = bytes_written / (1024 * 1024)
                print(f"Written: {progress:.1f} MB", end='\r')

    print(f"\nCreated {filename} ({bytes_written / (1024 * 1024):.1f} MB, {log_count} logs)")
    return filename


# Test with smaller file first
def test_small():
    print("Testing with 1MB file...")
    try:
        # Try the simple version first
        create_simple_log_file("test_small.log", 1)

        # Show first few lines
        with open("test_small.log", "r") as f:
            print("\nFirst 10 lines:")
            for i in range(10):
                line = f.readline().strip()
                print(f"  {i + 1}: {line}")

        # Clean up
        os.remove("test_small.log")
        print("\nTest successful!")

    except Exception as e:
        print(f"Error in test: {e}")


# Main execution
if __name__ == "__main__":
    # Run test
    test_small()

    # Ask user which version to run
    print("\n" + "=" * 50)
    print("Choose log generator version:")
    print("1. Advanced version (more realistic, but complex)")
    print("2. Simple version (faster, reliable)")

    choice = input("Enter choice (1 or 2): ").strip()

    if choice == "1":
        print("\nRunning advanced version...")
        try:
            log_file = create_log_file("advanced.log", 100)
        except Exception as e:
            print(f"Advanced version failed: {e}")
            print("Falling back to simple version...")
            log_file = create_simple_log_file("advanced.log", 100)
    else:
        print("\nRunning simple version...")
        log_file = create_simple_log_file("advanced.log", 100)

    print(f"\nFinal log file created: {log_file}")
    print(f"File size: {os.path.getsize(log_file) / (1024 * 1024):.2f} MB")